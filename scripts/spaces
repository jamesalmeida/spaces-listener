#!/usr/bin/env bash
set -euo pipefail

# spaces-listener: Record and transcribe X/Twitter Spaces
# Usage: spaces listen <url> [options]

VERSION="1.5.0"
OUTPUT_DIR="$HOME/Desktop/Spaces"
WHISPER_MODEL="base"
TRANSCRIBE=true
SUMMARIZE=true
SPACES_DIR="$HOME/.spaces-listener"

# Allow globs to expand to nothing without error
shopt -s nullglob

# Ensure spaces directory exists
mkdir -p "$SPACES_DIR"

show_help() {
    cat << EOF
spaces-listener v${VERSION}
Record and transcribe X/Twitter Spaces

USAGE:
    spaces listen <url> [options]    Start recording a Space
    spaces list                      List all active recordings
    spaces status [id]               Check recording status
    spaces stop [id|all]             Stop recording(s)
    spaces clean                     Remove stale pid/meta files
    spaces transcribe <file>         Transcribe an audio file
    spaces summarize <file>          Summarize a transcript file
    spaces help

OPTIONS:
    --output, -o DIR    Output directory (default: ~/Desktop/Spaces)
    --model MODEL       Whisper model: tiny|base|small|medium|large (default: base)
    --no-transcribe     Skip auto-transcription when recording ends
    --no-summarize      Skip auto-summarization after transcription
    --help, -h          Show this help

EXAMPLES:
    spaces listen "https://x.com/i/spaces/1ABC..."
    spaces listen "https://x.com/i/spaces/2DEF..." --output ~/Spaces
    spaces list
    spaces stop 1
    spaces stop all
    spaces clean

REQUIREMENTS:
    brew install yt-dlp ffmpeg openai-whisper
EOF
}

check_deps() {
    local missing=()
    command -v yt-dlp >/dev/null || missing+=("yt-dlp")
    command -v ffmpeg >/dev/null || missing+=("ffmpeg")
    
    if [[ "$TRANSCRIBE" == true ]]; then
        command -v whisper >/dev/null || missing+=("openai-whisper")
    fi
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "‚ùå Missing dependencies: ${missing[*]}"
        echo "   Install: brew install ${missing[*]}"
        exit 1
    fi
}

extract_username() {
    local url="$1"
    local info
    info=$(yt-dlp --dump-json "$url" 2>/dev/null | head -1) || true
    
    if [[ -n "$info" ]]; then
        local uploader
        uploader=$(echo "$info" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('uploader','unknown'))" 2>/dev/null) || uploader="unknown"
        uploader=$(echo "$uploader" | tr -cd '[:alnum:]_-' | head -c 30)
        echo "$uploader"
    else
        echo "space"
    fi
}

get_next_id() {
    local max_id=0
    for f in "$SPACES_DIR"/*.pid; do
        if [[ -f "$f" ]]; then
            local id
            id=$(basename "$f" .pid)
            if [[ "$id" =~ ^[0-9]+$ ]] && [[ "$id" -gt "$max_id" ]]; then
                max_id="$id"
            fi
        fi
    done
    echo $((max_id + 1))
}

list_recordings() {
    local found=false
    echo "üéß Active Recordings"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    
    for pid_file in "$SPACES_DIR"/*.pid; do
        if [[ -f "$pid_file" ]]; then
            local id
            id=$(basename "$pid_file" .pid)
            local pid
            pid=$(cat "$pid_file")
            local meta_file="$SPACES_DIR/${id}.meta"
            
            if ps -p "$pid" > /dev/null 2>&1; then
                found=true
                local username="unknown"
                local output_file=""
                local log_file=""
                
                if [[ -f "$meta_file" ]]; then
                    username=$(grep "^username=" "$meta_file" 2>/dev/null | cut -d= -f2 || echo "unknown")
                    output_file=$(grep "^output=" "$meta_file" 2>/dev/null | cut -d= -f2 || echo "")
                    log_file=$(grep "^log=" "$meta_file" 2>/dev/null | cut -d= -f2 || echo "")
                fi
                
                local progress=""
                if [[ -n "$log_file" && -f "$log_file" ]]; then
                    progress=$(grep -o "time=[0-9:.]*" "$log_file" 2>/dev/null | tail -1 | sed 's/time=//' || echo "")
                fi
                
                echo ""
                echo "  [$id] @${username}"
                echo "      PID: $pid"
                [[ -n "$progress" ]] && echo "      Recorded: $progress"
                [[ -n "$output_file" ]] && echo "      File: $(basename "$output_file")"
            else
                # Clean up stale files
                rm -f "$pid_file" "$meta_file"
            fi
        fi
    done
    
    if [[ "$found" == false ]]; then
        echo ""
        echo "  No active recordings"
    fi
    echo ""
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
}

clean_stale() {
    local cleaned_items=()

    for pid_file in "$SPACES_DIR"/*.pid; do
        if [[ -f "$pid_file" ]]; then
            local id
            id=$(basename "$pid_file" .pid)
            local pid
            pid=$(cat "$pid_file")
            local meta_file="$SPACES_DIR/${id}.meta"

            if ! ps -p "$pid" > /dev/null 2>&1; then
                cleaned_items+=("$pid_file")
                [[ -f "$meta_file" ]] && cleaned_items+=("$meta_file")
                rm -f "$pid_file" "$meta_file"
            fi
        fi
    done

    for meta_file in "$SPACES_DIR"/*.meta; do
        if [[ -f "$meta_file" ]]; then
            local id
            id=$(basename "$meta_file" .meta)
            local pid_file="$SPACES_DIR/${id}.pid"
            if [[ ! -f "$pid_file" ]]; then
                cleaned_items+=("$meta_file")
                rm -f "$meta_file"
            fi
        fi
    done

    if [[ ${#cleaned_items[@]} -eq 0 ]]; then
        echo "‚úÖ No stale pid/meta files found"
        return 0
    fi

    echo "üßπ Cleaned ${#cleaned_items[@]} stale file(s):"
    for item in "${cleaned_items[@]}"; do
        echo "  - $item"
    done
}

check_status() {
    local target_id="${1:-}"
    
    if [[ -z "$target_id" ]]; then
        list_recordings
        return 0
    fi
    
    local pid_file="$SPACES_DIR/${target_id}.pid"
    local meta_file="$SPACES_DIR/${target_id}.meta"
    
    if [[ ! -f "$pid_file" ]]; then
        echo "‚ùå Recording #$target_id not found"
        return 1
    fi
    
    local pid
    pid=$(cat "$pid_file")
    
    if ps -p "$pid" > /dev/null 2>&1; then
        local username="unknown"
        local output_file=""
        local log_file=""
        
        if [[ -f "$meta_file" ]]; then
            username=$(grep "^username=" "$meta_file" 2>/dev/null | cut -d= -f2 || echo "unknown")
            output_file=$(grep "^output=" "$meta_file" 2>/dev/null | cut -d= -f2 || echo "")
            log_file=$(grep "^log=" "$meta_file" 2>/dev/null | cut -d= -f2 || echo "")
        fi
        
        echo "üéß Recording #$target_id ‚Äî @${username}"
        echo "   PID: $pid"
        echo "   Status: Running"
        
        if [[ -n "$log_file" && -f "$log_file" ]]; then
            local progress
            progress=$(grep -o "time=[0-9:.]*" "$log_file" 2>/dev/null | tail -1 | sed 's/time=//' || echo "")
            [[ -n "$progress" ]] && echo "   Recorded: $progress"
        fi
        
        [[ -n "$output_file" ]] && echo "   Output: $output_file"
    else
        echo "Recording #$target_id has stopped"
        rm -f "$pid_file" "$meta_file"
    fi
}

stop_recording() {
    local target="${1:-}"
    
    if [[ -z "$target" ]]; then
        echo "Usage: spaces stop <id|all>"
        echo "       Run 'spaces list' to see recording IDs"
        return 1
    fi
    
    if [[ "$target" == "all" ]]; then
        local stopped=0
        for pid_file in "$SPACES_DIR"/*.pid; do
            if [[ -f "$pid_file" ]]; then
                local id
                id=$(basename "$pid_file" .pid)
                local pid
                pid=$(cat "$pid_file")
                
                if ps -p "$pid" > /dev/null 2>&1; then
                    echo "üõë Stopping recording #$id (PID: $pid)..."
                    kill "$pid" 2>/dev/null || true
                    stopped=$((stopped + 1))
                fi
                
                # Clean up and rename .part file
                local meta_file="$SPACES_DIR/${id}.meta"
                if [[ -f "$meta_file" ]]; then
                    local output_file
                    output_file=$(grep "^output=" "$meta_file" 2>/dev/null | cut -d= -f2 || echo "")
                    if [[ -n "$output_file" && -f "${output_file}.part" ]]; then
                        mv "${output_file}.part" "$output_file"
                        echo "   Saved: $output_file"
                    fi
                fi
                
                rm -f "$pid_file" "$meta_file"
            fi
        done
        
        if [[ $stopped -eq 0 ]]; then
            echo "No active recordings to stop"
        else
            echo "‚úÖ Stopped $stopped recording(s)"
        fi
    else
        local pid_file="$SPACES_DIR/${target}.pid"
        local meta_file="$SPACES_DIR/${target}.meta"
        
        if [[ ! -f "$pid_file" ]]; then
            echo "‚ùå Recording #$target not found"
            return 1
        fi
        
        local pid
        pid=$(cat "$pid_file")
        
        if ps -p "$pid" > /dev/null 2>&1; then
            echo "üõë Stopping recording #$target (PID: $pid)..."
            kill "$pid" 2>/dev/null || true
            sleep 1
            
            # Rename .part file
            if [[ -f "$meta_file" ]]; then
                local output_file
                output_file=$(grep "^output=" "$meta_file" 2>/dev/null | cut -d= -f2 || echo "")
                if [[ -n "$output_file" && -f "${output_file}.part" ]]; then
                    mv "${output_file}.part" "$output_file"
                    echo "‚úÖ Saved: $output_file"
                fi
            fi
        fi
        
        rm -f "$pid_file" "$meta_file"
        echo "Recording #$target stopped"
    fi
}

transcribe_file() {
    local audio_file="$1"
    
    if [[ ! -f "$audio_file" ]]; then
        echo "‚ùå File not found: $audio_file"
        exit 1
    fi
    
    echo "üìù Transcribing: $audio_file"
    echo "   Model: $WHISPER_MODEL"
    echo ""
    
    local output_dir
    output_dir=$(dirname "$audio_file")
    
    whisper "$audio_file" \
        --model "$WHISPER_MODEL" \
        --output_format txt \
        --output_dir "$output_dir" 2>&1 | grep -v "^$" | tail -10
    
    local base_name
    base_name=$(basename "$audio_file")
    base_name="${base_name%.*}"
    local transcript="${output_dir}/${base_name}.txt"
    # If file is named "recording.m4a", rename transcript to "transcript.txt"
    if [[ "$base_name" == "recording" ]]; then
        transcript="${output_dir}/transcript.txt"
    fi
    
    if [[ -f "$transcript" ]]; then
        echo ""
        echo "‚úÖ Transcript saved: $transcript"
        local words
        words=$(wc -w < "$transcript" | tr -d ' ')
        echo "   Words: $words"
        
        if [[ "$SUMMARIZE" == true ]]; then
            summarize_file "$transcript" || true
        fi
    fi
}

summarize_file() {
    local transcript="$1"
    
    if [[ ! -f "$transcript" ]]; then
        echo "‚ùå File not found: $transcript"
        return 1
    fi
    
    if [[ -z "${OPENAI_API_KEY:-}" ]]; then
        echo "‚ö†Ô∏è  OPENAI_API_KEY not set. Skipping summary."
        return 0
    fi
    
    if ! command -v curl >/dev/null 2>&1; then
        echo "‚ö†Ô∏è  curl not found. Skipping summary."
        return 0
    fi
    
    local output_dir
    output_dir=$(dirname "$transcript")
    local base_name
    base_name=$(basename "$transcript")
    base_name="${base_name%.*}"
    local summary_file="${output_dir}/${base_name}_summary.txt"
    # If file is named "transcript.txt", rename summary to "summary.txt"
    if [[ "$base_name" == "transcript" ]]; then
        summary_file="${output_dir}/summary.txt"
    fi
    
    local model="${SPACES_SUMMARY_MODEL:-gpt-4o-mini}"
    local payload
    payload=$(python3 - "$transcript" "$model" << 'PY'
import json
import sys

path = sys.argv[1]
model = sys.argv[2]
with open(path, "r", encoding="utf-8", errors="ignore") as f:
    content = f.read()

content = content[:100000]
system_prompt = (
    "You are an expert summarizer. Given a transcript of an X/Twitter Space "
    "conversation, provide a thorough summary covering:\n"
    "1. Speakers identified (if possible from context)\n"
    "2. Main topics discussed\n"
    "3. Key insights and takeaways\n"
    "4. Notable quotes or moments\n\n"
    "Format the summary with clear sections and bullet points. Be detailed but digestible."
)

data = {
    "model": model,
    "messages": [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": content},
    ],
    "temperature": 0.2,
}

print(json.dumps(data))
PY
)
    
    local response
    response=$(curl -sS https://api.openai.com/v1/chat/completions \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        -H "Content-Type: application/json" \
        -d "$payload") || {
            echo "‚ö†Ô∏è  Summary failed: API request error."
            return 0
        }
    
    local summary
    summary=$(printf '%s' "$response" | python3 - << 'PY'
import json
import sys

try:
    data = json.load(sys.stdin)
except Exception:
    sys.exit(2)

if "error" in data:
    sys.exit(3)

content = data.get("choices", [{}])[0].get("message", {}).get("content", "")
if not content:
    sys.exit(4)

print(content)
PY
    )
    
    local status=$?
    if [[ $status -ne 0 ]]; then
        local error_msg
        error_msg=$(printf '%s' "$response" | python3 - << 'PY'
import json
import sys

try:
    data = json.load(sys.stdin)
    error = data.get("error", {}).get("message", "")
    if error:
        print(error)
except Exception:
    pass
PY
        )
        
        if [[ -n "$error_msg" ]]; then
            echo "‚ö†Ô∏è  Summary failed: $error_msg"
        else
            echo "‚ö†Ô∏è  Summary failed: Unexpected API response."
        fi
        return 0
    fi
    
    printf '%s\n' "$summary" > "$summary_file"
    echo "‚úÖ Summary saved: $summary_file"
}

listen() {
    local url="$1"
    local username="$2"
    
    local id
    id=$(get_next_id)
    
    local date_str
    date_str=$(date +%Y-%m-%d_%H%M)
    local base_name="space_${username}_${date_str}"
    local space_dir="${OUTPUT_DIR}/${base_name}"
    mkdir -p "$space_dir"
    local audio_file="${space_dir}/recording.m4a"
    local log_file="${space_dir}/recording.log"
    
    echo "üéß Starting Space recording #$id..."
    echo "   URL: $url"
    echo "   Host: @${username}"
    echo "   Output: $audio_file"
    echo ""
    
    # Start recording in background with nohup
    nohup yt-dlp -f "bestaudio[ext=m4a]/bestaudio" \
        --no-warnings \
        -o "$audio_file" \
        "$url" > "$log_file" 2>&1 &

    local pid=$!

    nohup bash -c '
        pid="$1"
        audio_file="$2"
        while ps -p "$pid" >/dev/null 2>&1; do
            sleep 5
        done
        if command -v openclaw >/dev/null 2>&1; then
            openclaw gateway wake --text "Space recording complete: $audio_file" --mode now >/dev/null 2>&1 || true
        fi
    ' bash "$pid" "$audio_file" >/dev/null 2>&1 &

    # Save PID and metadata
    echo "$pid" > "$SPACES_DIR/${id}.pid"
    cat > "$SPACES_DIR/${id}.meta" << EOF
username=$username
url=$url
output=$audio_file
log=$log_file
started=$(date +%s)
EOF
    
    # Wait a moment and verify it started
    sleep 3
    
    if ps -p "$pid" > /dev/null 2>&1; then
        echo "‚úÖ Recording #$id started (PID: $pid)"
        echo ""
        echo "   Recording continues until the Space ends."
        echo "   You can close this terminal ‚Äî recording persists."
        echo ""
        echo "   Commands:"
        echo "   ‚Ä¢ spaces list       ‚Äî see all recordings"
        echo "   ‚Ä¢ spaces stop $id      ‚Äî stop this recording"
        echo ""
        
        # Show initial progress
        sleep 2
        if [[ -f "$log_file" ]]; then
            local progress
            progress=$(grep -o "time=[0-9:.]*" "$log_file" 2>/dev/null | tail -1 || echo "")
            if [[ -n "$progress" ]]; then
                echo "   Progress: $progress"
            fi
        fi
    else
        echo "‚ùå Recording failed to start"
        echo "   Check log: $log_file"
        rm -f "$SPACES_DIR/${id}.pid" "$SPACES_DIR/${id}.meta"
        exit 1
    fi
}

# Parse arguments
COMMAND=""
URL=""
AUDIO_FILE=""
TARGET_ID=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        listen)
            COMMAND="listen"
            shift
            ;;
        list)
            COMMAND="list"
            shift
            ;;
        status)
            COMMAND="status"
            shift
            if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
                TARGET_ID="$1"
                shift
            fi
            ;;
        clean)
            COMMAND="clean"
            shift
            ;;
        stop)
            COMMAND="stop"
            shift
            if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
                TARGET_ID="$1"
                shift
            fi
            ;;
        transcribe)
            COMMAND="transcribe"
            shift
            if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
                AUDIO_FILE="$1"
                shift
            fi
            ;;
        summarize)
            COMMAND="summarize"
            shift
            if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
                AUDIO_FILE="$1"
                shift
            fi
            ;;
        help|--help|-h)
            show_help
            exit 0
            ;;
        --version|-v)
            echo "spaces-listener v${VERSION}"
            exit 0
            ;;
        --output|-o)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --model)
            WHISPER_MODEL="$2"
            shift 2
            ;;
        --no-transcribe)
            TRANSCRIBE=false
            shift
            ;;
        --no-summarize)
            SUMMARIZE=false
            shift
            ;;
        http*|https*)
            URL="$1"
            shift
            ;;
        *)
            if [[ -z "$URL" && "$1" =~ ^[0-9a-zA-Z] ]]; then
                URL="$1"
            fi
            shift
            ;;
    esac
done

# Handle commands
case "$COMMAND" in
    list)
        list_recordings
        exit 0
        ;;
    status)
        check_status "$TARGET_ID"
        exit $?
        ;;
    stop)
        stop_recording "$TARGET_ID"
        exit 0
        ;;
    clean)
        clean_stale
        exit 0
        ;;
    transcribe)
        if [[ -z "$AUDIO_FILE" ]]; then
            echo "‚ùå Usage: spaces transcribe <audio_file>"
            exit 1
        fi
        check_deps
        transcribe_file "$AUDIO_FILE"
        exit 0
        ;;
    summarize)
        if [[ -z "$AUDIO_FILE" ]]; then
            echo "‚ùå Usage: spaces summarize <transcript_file>"
            exit 1
        fi
        summarize_file "$AUDIO_FILE"
        exit 0
        ;;
    listen|"")
        if [[ -z "$URL" ]]; then
            show_help
            exit 1
        fi
        COMMAND="listen"
        ;;
esac

# Ensure output directory exists
mkdir -p "$OUTPUT_DIR"

# Check dependencies
check_deps

# Extract username
echo "üîç Fetching Space info..."
USERNAME=$(extract_username "$URL")

# Start recording
listen "$URL" "$USERNAME"
