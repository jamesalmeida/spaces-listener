#!/usr/bin/env bash
set -euo pipefail

# spaces-listener: Record and transcribe X/Twitter Spaces
# Usage: spaces listen <url> [options]

VERSION="1.3.0"
OUTPUT_DIR="$HOME/Desktop"
WHISPER_MODEL="base"
TRANSCRIBE=true
SPACES_DIR="$HOME/.spaces-listener"

# Ensure spaces directory exists
mkdir -p "$SPACES_DIR"

show_help() {
    cat << EOF
spaces-listener v${VERSION}
Record and transcribe X/Twitter Spaces

USAGE:
    spaces listen <url> [options]    Start recording a Space
    spaces list                      List all active recordings
    spaces status [id]               Check recording status
    spaces stop [id|all]             Stop recording(s)
    spaces transcribe <file>         Transcribe an audio file
    spaces help

OPTIONS:
    --output, -o DIR    Output directory (default: ~/Desktop)
    --model MODEL       Whisper model: tiny|base|small|medium|large (default: base)
    --no-transcribe     Skip auto-transcription when recording ends
    --help, -h          Show this help

EXAMPLES:
    spaces listen "https://x.com/i/spaces/1ABC..."
    spaces listen "https://x.com/i/spaces/2DEF..." --output ~/Spaces
    spaces list
    spaces stop 1
    spaces stop all

REQUIREMENTS:
    brew install yt-dlp ffmpeg openai-whisper
EOF
}

check_deps() {
    local missing=()
    command -v yt-dlp >/dev/null || missing+=("yt-dlp")
    command -v ffmpeg >/dev/null || missing+=("ffmpeg")
    
    if [[ "$TRANSCRIBE" == true ]]; then
        command -v whisper >/dev/null || missing+=("openai-whisper")
    fi
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "‚ùå Missing dependencies: ${missing[*]}"
        echo "   Install: brew install ${missing[*]}"
        exit 1
    fi
}

extract_username() {
    local url="$1"
    local info
    info=$(yt-dlp --dump-json "$url" 2>/dev/null | head -1) || true
    
    if [[ -n "$info" ]]; then
        local uploader
        uploader=$(echo "$info" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('uploader','unknown'))" 2>/dev/null) || uploader="unknown"
        uploader=$(echo "$uploader" | tr -cd '[:alnum:]_-' | head -c 30)
        echo "$uploader"
    else
        echo "space"
    fi
}

get_next_id() {
    local max_id=0
    for f in "$SPACES_DIR"/*.pid 2>/dev/null; do
        if [[ -f "$f" ]]; then
            local id
            id=$(basename "$f" .pid)
            if [[ "$id" =~ ^[0-9]+$ ]] && [[ "$id" -gt "$max_id" ]]; then
                max_id="$id"
            fi
        fi
    done
    echo $((max_id + 1))
}

list_recordings() {
    local found=false
    echo "üéß Active Recordings"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    
    for pid_file in "$SPACES_DIR"/*.pid 2>/dev/null; do
        if [[ -f "$pid_file" ]]; then
            local id
            id=$(basename "$pid_file" .pid)
            local pid
            pid=$(cat "$pid_file")
            local meta_file="$SPACES_DIR/${id}.meta"
            
            if ps -p "$pid" > /dev/null 2>&1; then
                found=true
                local username="unknown"
                local output_file=""
                local log_file=""
                
                if [[ -f "$meta_file" ]]; then
                    username=$(grep "^username=" "$meta_file" 2>/dev/null | cut -d= -f2 || echo "unknown")
                    output_file=$(grep "^output=" "$meta_file" 2>/dev/null | cut -d= -f2 || echo "")
                    log_file=$(grep "^log=" "$meta_file" 2>/dev/null | cut -d= -f2 || echo "")
                fi
                
                local progress=""
                if [[ -n "$log_file" && -f "$log_file" ]]; then
                    progress=$(grep -o "time=[0-9:.]*" "$log_file" 2>/dev/null | tail -1 | sed 's/time=//' || echo "")
                fi
                
                echo ""
                echo "  [$id] @${username}"
                echo "      PID: $pid"
                [[ -n "$progress" ]] && echo "      Recorded: $progress"
                [[ -n "$output_file" ]] && echo "      File: $(basename "$output_file")"
            else
                # Clean up stale files
                rm -f "$pid_file" "$meta_file"
            fi
        fi
    done
    
    if [[ "$found" == false ]]; then
        echo ""
        echo "  No active recordings"
    fi
    echo ""
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
}

check_status() {
    local target_id="${1:-}"
    
    if [[ -z "$target_id" ]]; then
        list_recordings
        return 0
    fi
    
    local pid_file="$SPACES_DIR/${target_id}.pid"
    local meta_file="$SPACES_DIR/${target_id}.meta"
    
    if [[ ! -f "$pid_file" ]]; then
        echo "‚ùå Recording #$target_id not found"
        return 1
    fi
    
    local pid
    pid=$(cat "$pid_file")
    
    if ps -p "$pid" > /dev/null 2>&1; then
        local username="unknown"
        local output_file=""
        local log_file=""
        
        if [[ -f "$meta_file" ]]; then
            username=$(grep "^username=" "$meta_file" 2>/dev/null | cut -d= -f2 || echo "unknown")
            output_file=$(grep "^output=" "$meta_file" 2>/dev/null | cut -d= -f2 || echo "")
            log_file=$(grep "^log=" "$meta_file" 2>/dev/null | cut -d= -f2 || echo "")
        fi
        
        echo "üéß Recording #$target_id ‚Äî @${username}"
        echo "   PID: $pid"
        echo "   Status: Running"
        
        if [[ -n "$log_file" && -f "$log_file" ]]; then
            local progress
            progress=$(grep -o "time=[0-9:.]*" "$log_file" 2>/dev/null | tail -1 | sed 's/time=//' || echo "")
            [[ -n "$progress" ]] && echo "   Recorded: $progress"
        fi
        
        [[ -n "$output_file" ]] && echo "   Output: $output_file"
    else
        echo "Recording #$target_id has stopped"
        rm -f "$pid_file" "$meta_file"
    fi
}

stop_recording() {
    local target="${1:-}"
    
    if [[ -z "$target" ]]; then
        echo "Usage: spaces stop <id|all>"
        echo "       Run 'spaces list' to see recording IDs"
        return 1
    fi
    
    if [[ "$target" == "all" ]]; then
        local stopped=0
        for pid_file in "$SPACES_DIR"/*.pid 2>/dev/null; do
            if [[ -f "$pid_file" ]]; then
                local id
                id=$(basename "$pid_file" .pid)
                local pid
                pid=$(cat "$pid_file")
                
                if ps -p "$pid" > /dev/null 2>&1; then
                    echo "üõë Stopping recording #$id (PID: $pid)..."
                    kill "$pid" 2>/dev/null || true
                    stopped=$((stopped + 1))
                fi
                
                # Clean up and rename .part file
                local meta_file="$SPACES_DIR/${id}.meta"
                if [[ -f "$meta_file" ]]; then
                    local output_file
                    output_file=$(grep "^output=" "$meta_file" 2>/dev/null | cut -d= -f2 || echo "")
                    if [[ -n "$output_file" && -f "${output_file}.part" ]]; then
                        mv "${output_file}.part" "$output_file"
                        echo "   Saved: $output_file"
                    fi
                fi
                
                rm -f "$pid_file" "$meta_file"
            fi
        done
        
        if [[ $stopped -eq 0 ]]; then
            echo "No active recordings to stop"
        else
            echo "‚úÖ Stopped $stopped recording(s)"
        fi
    else
        local pid_file="$SPACES_DIR/${target}.pid"
        local meta_file="$SPACES_DIR/${target}.meta"
        
        if [[ ! -f "$pid_file" ]]; then
            echo "‚ùå Recording #$target not found"
            return 1
        fi
        
        local pid
        pid=$(cat "$pid_file")
        
        if ps -p "$pid" > /dev/null 2>&1; then
            echo "üõë Stopping recording #$target (PID: $pid)..."
            kill "$pid" 2>/dev/null || true
            sleep 1
            
            # Rename .part file
            if [[ -f "$meta_file" ]]; then
                local output_file
                output_file=$(grep "^output=" "$meta_file" 2>/dev/null | cut -d= -f2 || echo "")
                if [[ -n "$output_file" && -f "${output_file}.part" ]]; then
                    mv "${output_file}.part" "$output_file"
                    echo "‚úÖ Saved: $output_file"
                fi
            fi
        fi
        
        rm -f "$pid_file" "$meta_file"
        echo "Recording #$target stopped"
    fi
}

transcribe_file() {
    local audio_file="$1"
    
    if [[ ! -f "$audio_file" ]]; then
        echo "‚ùå File not found: $audio_file"
        exit 1
    fi
    
    echo "üìù Transcribing: $audio_file"
    echo "   Model: $WHISPER_MODEL"
    echo ""
    
    local output_dir
    output_dir=$(dirname "$audio_file")
    
    whisper "$audio_file" \
        --model "$WHISPER_MODEL" \
        --output_format txt \
        --output_dir "$output_dir" 2>&1 | grep -v "^$" | tail -10
    
    local base_name
    base_name=$(basename "$audio_file" .m4a)
    local transcript="${output_dir}/${base_name}.txt"
    
    if [[ -f "$transcript" ]]; then
        echo ""
        echo "‚úÖ Transcript saved: $transcript"
        local words
        words=$(wc -w < "$transcript" | tr -d ' ')
        echo "   Words: $words"
    fi
}

listen() {
    local url="$1"
    local username="$2"
    
    local id
    id=$(get_next_id)
    
    local date_str
    date_str=$(date +%Y-%m-%d_%H%M)
    local base_name="space_${username}_${date_str}"
    local audio_file="${OUTPUT_DIR}/${base_name}.m4a"
    local log_file="${OUTPUT_DIR}/${base_name}.log"
    
    echo "üéß Starting Space recording #$id..."
    echo "   URL: $url"
    echo "   Host: @${username}"
    echo "   Output: $audio_file"
    echo ""
    
    # Start recording in background with nohup
    nohup yt-dlp -f "bestaudio[ext=m4a]/bestaudio" \
        --no-warnings \
        -o "$audio_file" \
        "$url" > "$log_file" 2>&1 &
    
    local pid=$!
    
    # Save PID and metadata
    echo "$pid" > "$SPACES_DIR/${id}.pid"
    cat > "$SPACES_DIR/${id}.meta" << EOF
username=$username
url=$url
output=$audio_file
log=$log_file
started=$(date +%s)
EOF
    
    # Wait a moment and verify it started
    sleep 3
    
    if ps -p "$pid" > /dev/null 2>&1; then
        echo "‚úÖ Recording #$id started (PID: $pid)"
        echo ""
        echo "   Recording continues until the Space ends."
        echo "   You can close this terminal ‚Äî recording persists."
        echo ""
        echo "   Commands:"
        echo "   ‚Ä¢ spaces list       ‚Äî see all recordings"
        echo "   ‚Ä¢ spaces stop $id      ‚Äî stop this recording"
        echo ""
        
        # Show initial progress
        sleep 2
        if [[ -f "$log_file" ]]; then
            local progress
            progress=$(grep -o "time=[0-9:.]*" "$log_file" 2>/dev/null | tail -1 || echo "")
            if [[ -n "$progress" ]]; then
                echo "   Progress: $progress"
            fi
        fi
    else
        echo "‚ùå Recording failed to start"
        echo "   Check log: $log_file"
        rm -f "$SPACES_DIR/${id}.pid" "$SPACES_DIR/${id}.meta"
        exit 1
    fi
}

# Parse arguments
COMMAND=""
URL=""
AUDIO_FILE=""
TARGET_ID=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        listen)
            COMMAND="listen"
            shift
            ;;
        list)
            COMMAND="list"
            shift
            ;;
        status)
            COMMAND="status"
            shift
            if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
                TARGET_ID="$1"
                shift
            fi
            ;;
        stop)
            COMMAND="stop"
            shift
            if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
                TARGET_ID="$1"
                shift
            fi
            ;;
        transcribe)
            COMMAND="transcribe"
            shift
            if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
                AUDIO_FILE="$1"
                shift
            fi
            ;;
        help|--help|-h)
            show_help
            exit 0
            ;;
        --version|-v)
            echo "spaces-listener v${VERSION}"
            exit 0
            ;;
        --output|-o)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --model)
            WHISPER_MODEL="$2"
            shift 2
            ;;
        --no-transcribe)
            TRANSCRIBE=false
            shift
            ;;
        http*|https*)
            URL="$1"
            shift
            ;;
        *)
            if [[ -z "$URL" && "$1" =~ ^[0-9a-zA-Z] ]]; then
                URL="$1"
            fi
            shift
            ;;
    esac
done

# Handle commands
case "$COMMAND" in
    list)
        list_recordings
        exit 0
        ;;
    status)
        check_status "$TARGET_ID"
        exit $?
        ;;
    stop)
        stop_recording "$TARGET_ID"
        exit 0
        ;;
    transcribe)
        if [[ -z "$AUDIO_FILE" ]]; then
            echo "‚ùå Usage: spaces transcribe <audio_file>"
            exit 1
        fi
        check_deps
        transcribe_file "$AUDIO_FILE"
        exit 0
        ;;
    listen|"")
        if [[ -z "$URL" ]]; then
            show_help
            exit 1
        fi
        COMMAND="listen"
        ;;
esac

# Ensure output directory exists
mkdir -p "$OUTPUT_DIR"

# Check dependencies
check_deps

# Extract username
echo "üîç Fetching Space info..."
USERNAME=$(extract_username "$URL")

# Start recording
listen "$URL" "$USERNAME"
